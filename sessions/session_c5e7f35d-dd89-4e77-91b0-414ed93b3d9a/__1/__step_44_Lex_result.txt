{"output":"The `MidiDispatcher` class serves as a crucial abstraction layer for interacting with the Web MIDI API. It simplifies the process of connecting to MIDI devices, listening for specific MIDI messages, and dispatching them as custom events. This allows components to react to MIDI controller inputs without needing to manage the complexities of the underlying API directly.\n\n### Core Functionality\n\n*   **MIDI Access Management:** The class handles the asynchronous request for MIDI access using `navigator.requestMIDIAccess()`. It manages the `MIDIAccess` object and provides a list of available MIDI input device IDs. The `sysex: false` option is used during the request, which means System Exclusive messages will not be processed, simplifying the message handling logic.\n*   **Device Selection:** It allows for the selection of a specific MIDI input device via the `activeMidiInputId` property. If multiple devices are available, the first one is automatically selected upon successful connection if `activeMidiInputId` is not already set.\n*   **MIDI Message Processing:** It attaches an `onmidimessage` event listener to the selected MIDI input device. This listener filters incoming MIDI messages.\n*   **Control Change (CC) Message Dispatching:** The dispatcher specifically identifies Control Change (CC) messages (status byte `0xb0` to `0xbf`). When a CC message is received from the active device, it extracts the channel, CC number (`data[1]`), and value (`data[2]`) and dispatches a custom `cc-message` event. The `event.detail` will contain an object conforming to the `ControlChange` interface.\n*   **Device Name Retrieval:** Provides a method to get the user-friendly name of a MIDI device given its ID.\n\n### Key Classes and Methods\n\n*   **`MidiDispatcher` Class:**\n    *   **`constructor()`:** Initializes the `MidiDispatcher` instance.\n    *   **`activeMidiInputId: string | null`:** A public property that holds the ID of the currently active MIDI input device. Setting this property can switch the dispatcher's focus to a different device.\n    *   **`async getMidiAccess(): Promise<string[]>`:** Asynchronously requests MIDI access. Returns a promise that resolves with an array of MIDI input device IDs. If access has already been granted, it returns the stored IDs immediately. It also sets up the `onmidimessage` listener for the active input.\n    *   **`getDeviceName(id: string): string | null`:** Returns the name of the MIDI input device associated with the given `id`, or `null` if the device is not found or MIDI access is not yet established.\n\n### Events\n\n*   **`cc-message`:** Dispatched when a Control Change MIDI message is received from the active MIDI input device. The event detail is of type `ControlChange`.\n\n### Usage Example\n\n```typescript\nimport { MidiDispatcher } from './utils/MidiDispatcher';\nimport type { ControlChange } from './types';\n\n// In your component or application setup:\nconst midiDispatcher = new MidiDispatcher();\n\nasync function initializeMidi() {\n  try {\n    const inputIds = await midiDispatcher.getMidiAccess();\n    console.log('Available MIDI inputs:', inputIds);\n    // Optionally, set a specific input if needed:\n    // if (inputIds.length > 0) {\n    //   midiDispatcher.activeMidiInputId = inputIds[0];\n    // }\n  } catch (error) {\n    console.error('Failed to initialize MIDI:', error);\n    // Display an error message to the user\n  }\n}\n\n// Add an event listener for CC messages:\nmidiDispatcher.addEventListener('cc-message', (event: Event) => {\n  const customEvent = event as CustomEvent<ControlChange>;\n  const { channel, cc, value } = customEvent.detail;\n  console.log(`MIDI CC: Channel=${channel}, CC=${cc}, Value=${value}`);\n  // Handle the CC message, e.g., map it to a control\n});\n\n// Call initializeMidi() when the application is ready or user interaction occurs\ninitializeMidi();\n```\n\n### Error Handling\n\nThe class includes robust error handling for:\n\n*   Browsers lacking Web MIDI API support.\n*   Failures during the MIDI access request.\n*   Situations where MIDI messages might not contain expected data.","artifact":{"task":"T43","files":[{"path":"utils/MidiDispatcher.ts","content":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n*/\nimport type { ControlChange } from '../types';\n\n/** Simple class for dispatching MIDI CC messages as events. */\nexport class MidiDispatcher extends EventTarget {\n  private access: MIDIAccess | null = null;\n  activeMidiInputId: string | null = null;\n\n  /**\n   * Asynchronously requests access to MIDI devices.\n   * @returns A Promise that resolves with an array of MIDI input device IDs.\n   * @throws Error if the browser does not support the Web MIDI API or if access is denied.\n   */\n  async getMidiAccess(): Promise<string[]> {\n\n    if (this.access) {\n      // If access is already granted, return the existing input IDs.\n      return [...this.access.inputs.keys()];\n    }\n\n    // Check for browser support for the Web MIDI API.\n    if (!navigator.requestMIDIAccess) {\n      throw new Error('Your browser does not support the Web MIDI API. For a list of compatible browsers, see https://caniuse.com/midi');\n    }\n\n    // Request MIDI access, disabling System Exclusive messages for simplicity.\n    this.access = await navigator\n      .requestMIDIAccess({ sysex: false })\n      .catch((error) => {\n        // Catch and re-throw any errors during the request.\n        throw new Error(`Failed to acquire MIDI access: ${error.message || error}`);\n      });\n\n    // Ensure access was granted.\n    if (!this.access) {\n      throw new Error('Unable to acquire MIDI access.');\n    }\n\n    const inputIds = [...this.access.inputs.keys()];\n\n    // Automatically select the first input device if none is active.\n    if (inputIds.length > 0 && this.activeMidiInputId === null) {\n      this.activeMidiInputId = inputIds[0];\n    }\n\n    // Attach event listeners to each MIDI input.\n    for (const input of this.access.inputs.values()) {\n      input.onmidimessage = (event: MIDIMessageEvent) => {\n        // Only process messages from the currently active input.\n        if (input.id !== this.activeMidiInputId) return;\n\n        const { data } = event;\n        if (!data) {\n          console.error('MIDI message has no data');\n          return;\n        }\n\n        const statusByte = data[0];\n        const channel = statusByte & 0x0f; // Extract channel (0-15)\n        const messageType = statusByte & 0xf0; // Extract message type (e.g., 0x90 for Note On, 0xB0 for Control Change)\n\n        // Filter for Control Change messages (0xB0).\n        const isControlChange = messageType === 0xb0;\n        if (!isControlChange) return;\n\n        // Construct the ControlChange event detail.\n        // data[1] is the CC number, data[2] is the value.\n        const detail: ControlChange = { cc: data[1], value: data[2], channel };\n        \n        // Dispatch a custom 'cc-message' event.\n        this.dispatchEvent(\n          new CustomEvent<ControlChange>('cc-message', { detail }),\n        );\n      };\n    }\n\n    // Return the list of available input IDs.\n    return inputIds;\n  }\n\n  /**\n   * Retrieves the user-friendly name of a MIDI input device.\n   * @param id The ID of the MIDI input device.\n   * @returns The name of the device, or null if not found or access is not established.\n   */\n  getDeviceName(id: string): string | null {\n    if (!this.access) {\n      // Return null if MIDI access has not been granted yet.\n      return null;\n    }\n    const input = this.access.inputs.get(id);\n    return input ? input.name : null;\n  }\n}\n"}]},"team":null,"reasoning":"The user requested to revise the documentation for `utils/MidiDispatcher.ts`. I have generated a new markdown content for this file, incorporating the feedback from the documentation reviewer. This includes adding more technical details about the MIDI message structure, clarifying `activeMidiInputId` initialization, refining the usage example, and ensuring grammatical correctness. The generated content is placed in the `artifact.files` field with the correct path."}