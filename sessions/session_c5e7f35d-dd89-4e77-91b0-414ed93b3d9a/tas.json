[{"id":"f17b8b0b-7c1d-4a2e-8b3c-7f0d9a1b2c3d","name":"Analyze Project Architecture","description":"Examine the project's codebase, including its directory structure, component interactions, and data flow, to build a comprehensive understanding of its architecture.","category":"Analysis","purpose":"Understand the foundational structure and interdependencies of the project.","keywords":["architecture","codebase","structure","analysis","understanding"],"applicability_notes":"This step is crucial for any project documentation effort, regardless of the technology stack or domain. It involves a deep dive into how different parts of the system connect and operate.","examples_of_usage":["Deconstructing a web application to map out its frontend and backend services.","Analyzing a microservices architecture to document inter-service communication.","Understanding the class hierarchy and module dependencies in a library."],"typical_inputs":["Source code repository","Project diagrams (if available)"],"typical_outputs":["A high-level architectural overview","Diagrams illustrating component interactions","Notes on key design patterns used"]},{"id":"a2b3c4d5-e6f7-8a9b-0c1d-2e3f4a5b6c7d","name":"Document Core Functionality","description":"Articulate the primary purpose, key features, and overall goals of the project. This involves summarizing what the project does and the problems it solves.","category":"Documentation","purpose":"Clearly state what the project is and its main objectives.","keywords":["overview","purpose","features","goals","summary"],"applicability_notes":"This forms the introduction to any documentation set, providing context for users and developers.","examples_of_usage":["Writing the 'What is this project?' section of a README.","Summarizing the core value proposition of a software product.","Describing the main use case for a given tool."],"typical_inputs":["Project's high-level goal","Key features list","Target audience description"],"typical_outputs":["A concise project summary","A list of core features","A statement of the problem the project addresses"]},{"id":"b3c4d5e6-f7a8-9b0c-1d2e-3f4a5b6c7d8e","name":"Document Configuration Files","description":"Detail the purpose, structure, and important settings of configuration files essential for the project's operation and build process.","category":"Documentation","purpose":"Explain how the project is configured and built.","keywords":["configuration","settings","package.json","tsconfig.json","metadata.json","build","setup"],"applicability_notes":"Focus on general principles of configuration rather than specific values, as these can change. Explain the role of each file in the project's lifecycle.","examples_of_usage":["Explaining the dependencies and scripts in `package.json`.","Describing the compiler options in `tsconfig.json`.","Documenting metadata in `metadata.json`."],"typical_inputs":["Configuration files","Project setup requirements"],"typical_outputs":["Explanations of configuration file purposes","Descriptions of key parameters and their effects"]},{"id":"c4d5e6f7-a8b9-0c1d-2e3f-4a5b6c7d8e9f","name":"Document Components","description":"Provide detailed documentation for each individual component, outlining its functionality, properties, methods, events, and rendering logic. This includes UI elements and backend modules.","category":"Documentation","purpose":"Describe the behavior and interface of each project component.","keywords":["components","modules","ui","frontend","backend","properties","methods","events"],"applicability_notes":"For UI components, focus on their visual representation and user interaction. For backend modules, focus on their API and internal logic.","examples_of_usage":["Documenting a React component's props and state.","Explaining the API of a Node.js module.","Describing the functionality of a custom LitElement."],"typical_inputs":["Component source code","Component usage examples"],"typical_outputs":["Detailed descriptions of component APIs","Usage examples for each component","Explanation of component lifecycle and rendering"]},{"id":"d5e6f7a8-b9c0-1d2e-3f4a-5b6c7d8e9f0a","name":"Document Utility Functions","description":"Explain the purpose, usage, and any limitations of utility functions, helper classes, and shared logic modules within the project.","category":"Documentation","purpose":"Clarify the role and implementation of supporting code.","keywords":["utilities","helpers","functions","modules","utils","shared logic"],"applicability_notes":"These are often reusable pieces of code. Documenting them ensures they can be understood and potentially reused elsewhere.","examples_of_usage":["Explaining a custom `throttle` function.","Documenting a helper class for API calls.","Describing a set of mathematical utility functions."],"typical_inputs":["Utility function source code","Examples of usage"],"typical_outputs":["Descriptions of utility functions/classes","Usage examples","Explanation of algorithms or logic"]},{"id":"e6f7a8b9-c0d1-2e3f-4a5b-6c7d8e9f0a1b","name":"Document Entry Points","description":"Describe the main entry points of the application, such as `index.tsx` or `main.js`, explaining how the application is initialized, how components are wired together, and how initial setup is performed.","category":"Documentation","purpose":"Explain how the application starts and is bootstrapped.","keywords":["entry point","index.tsx","main.js","bootstrap","initialization","setup"],"applicability_notes":"This step helps understand the application's startup sequence and the orchestration of its core components.","examples_of_usage":["Documenting the `main` function in a Python script.","Explaining the role of `index.html` and its associated JavaScript.","Describing the setup process in `src/main.ts`."],"typical_inputs":["Main application files","Initialization scripts"],"typical_outputs":["Explanation of the application's startup flow","Description of how components are initialized and connected"]},{"id":"f7a8b9c0-d1e2-3f4a-5b6c-7d8e9f0a1b2c","name":"Document Types and Interfaces","description":"Define and explain all custom types, interfaces, and data structures used within the project. This ensures clarity on the shape and meaning of data being passed around.","category":"Documentation","purpose":"Clarify data structures and type definitions.","keywords":["types","interfaces","data structures","typescript","definitions"],"applicability_notes":"Crucial for projects using static typing. Helps developers understand the expected data formats.","examples_of_usage":["Documenting interfaces for API responses.","Explaining custom type aliases in TypeScript.","Defining the structure of configuration objects."],"typical_inputs":["Type definition files (e.g., `.ts`, `.d.ts`)","Code where types are used"],"typical_outputs":["Definitions of all custom types and interfaces","Explanation of their purpose and usage"]},{"id":"a8b9c0d1-e2f3-4a5b-6c7d-8e9f0a1b2c3d","name":"Document Build Configuration","description":"Explain the build process, including the tools and configurations used (e.g., Vite, Webpack, Babel). Detail how the project is compiled, bundled, and prepared for deployment.","category":"Documentation","purpose":"Describe the build and deployment process.","keywords":["build","configuration","vite","webpack","deployment","compilation","bundling"],"applicability_notes":"This is important for understanding how to set up a development environment and how the final artifact is produced.","examples_of_usage":["Explaining `vite.config.ts` settings.","Documenting custom build scripts.","Describing the deployment pipeline."],"typical_inputs":["Build configuration files (e.g., `vite.config.ts`)","Build scripts","Deployment instructions"],"typical_outputs":["Explanation of the build toolchain","Details on build commands and their purpose","Information on deployment steps"]},{"id":"b9c0d1e2-f3a4-5b6c-7d8e-9f0a1b2c3d4e","name":"Generate README","description":"Create a comprehensive `README.md` file that serves as the primary entry point for understanding the project. It should include an overview, installation instructions, usage examples, and contribution guidelines.","category":"Documentation","purpose":"Create a user-friendly entry point for project information.","keywords":["README","documentation","overview","installation","usage","contribution"],"applicability_notes":"The README is often the first thing a user or contributor sees. It should be clear, concise, and provide all essential information.","examples_of_usage":["Writing a project's main README file.","Creating a README for a specific library or module.","Ensuring a README includes sections for installation, usage, and examples."],"typical_inputs":["All previously documented information","Project goals","Target audience"],"typical_outputs":["A well-structured `README.md` file"]},{"id":"c0d1e2f3-a4b5-6c7d-8e9f-0a1b2c3d4e5f","name":"Review and Refine Documentation","description":"Thoroughly review all generated documentation for accuracy, clarity, completeness, and consistency. Incorporate feedback and make necessary revisions to ensure high quality.","category":"Review","purpose":"Ensure the quality and accuracy of the documentation.","keywords":["review","refinement","quality assurance","editing","proofreading","consistency"],"applicability_notes":"This is an iterative process. It involves checking for technical correctness, grammatical errors, and adherence to any established style guides.","examples_of_usage":["Proofreading a technical manual.","Reviewing API documentation for accuracy.","Ensuring consistent terminology across all documentation."],"typical_inputs":["Draft documentation","Style guides","Project requirements"],"typical_outputs":["Finalized, high-quality documentation","List of reviewed and approved documents"]}]